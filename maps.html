<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EstateMap &mdash; Property Explorer</title>
  <link rel="shortcut icon" href="assets/images/logo/favicon.png" type="image/x-icon" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
    rel="stylesheet" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="anonymous" />
  <style>
    :root {
      --primary: #006666;
      --primary-dark: #003f44;
      --accent: #24c789;
      --accent-dark: #1e9d6d;
      --neutral-100: #ffffff;
      --neutral-200: #f0f4f8;
      --neutral-300: #d9e1ec;
      --neutral-400: #94a3b8;
      --neutral-500: #64748b;
      --heading: #0f172a;
      --radius-lg: 24px;
      --radius-md: 18px;
      --shadow-soft: 0 18px 45px rgba(15, 23, 42, 0.08);
      font-family: "Poppins", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: #f5f7fb;
      color: var(--heading);
      font-family: "Poppins", sans-serif;
    }

    a {
      color: inherit;
    }

    .page {
      display: flex;
      gap: 32px;
      padding: 10px clamp(16px, 4vw, 0px);
      min-height: 100vh;
    }

    .sidebar {
      width: clamp(280px, 22vw, 360px);
      background: var(--neutral-100);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-soft);
      padding: 28px;
      display: flex;
      flex-direction: column;
      gap: 22px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .brand svg {
      width: 36px;
      height: 36px;
      fill: var(--primary);
    }

    .brand h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
      color: var(--primary-dark);
    }

    .location-search {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .location-search label {
      font-size: 14px;
      color: var(--neutral-500);
      font-weight: 500;
    }

    .input-group {
      display: flex;
      gap: 10px;
      flex-direction: column;
    }

    .input-group label {
      font-size: 13px;
      color: var(--neutral-500);
      font-weight: 500;
    }

    .input-group input,
    .input-group select {
      flex: 1;
      padding: 12px 14px;
      border: 1px solid var(--neutral-300);
      border-radius: 12px;
      font-family: inherit;
      font-size: 14px;
      background: #f8fafc;

    }

    .filter-fields {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-group button {
      padding: 12px 18px;
      background: var(--neutral-100);
      border-radius: 12px;
      border: 1px solid var(--neutral-300);
      font-weight: 500;
      color: var(--primary);
      cursor: pointer;
      transition: background 0.2s ease;
      text-align: left;
    }

    .input-group button:hover {
      background: var(--neutral-200);
    }

    .filters {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .filters h2 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--heading);
    }

    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .filter-group label {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      color: var(--neutral-500);
      cursor: pointer;
    }

    .filter-group label input {
      width: 18px;
      height: 18px;
      accent-color: var(--primary);
    }

    .filter-actions {
      display: flex;
      gap: 12px;
      margin-top: 12px;
    }

    .filter-actions button {
      flex: 1;
      border-radius: 12px;
      padding: 12px 0;
      border: none;
      font-weight: 600;
      cursor: pointer;
    }

    .filter-actions .primary {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 12px 22px rgba(0, 102, 102, 0.2);
    }

    .filter-actions .secondary {
      background: #e2e8f0;
      color: var(--primary-dark);
    }

    .map-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 24px;
      min-height: calc(100vh - 32px);
    }

    .tabs {
      display: flex;
      align-items: center;
      gap: 14px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: var(--radius-lg);
      padding: 14px 22px;
      box-shadow: var(--shadow-soft);
    }

    .tabs button {
      padding: 10px 18px;
      border-radius: 999px;
      border: none;
      background: transparent;
      font-weight: 600;
      font-size: 14px;
      color: var(--neutral-500);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tabs button.active {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 12px 24px rgba(0, 102, 102, 0.18);
    }

    .map-canvas {
      position: relative;
      flex: 1;
      border-radius: var(--radius-lg);
      overflow: hidden;
      box-shadow: var(--shadow-soft);
      min-height: clamp(520px, 70vh, 820px);
      background: #0f172a;
    }

    #propertyMap {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .map-legend {
      position: absolute;
      top: 18px;
      left: 18px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 12px 16px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.8);
      backdrop-filter: blur(12px);
      color: #fff;
      font-size: 13px;
      z-index: 500;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: currentColor;
      display: inline-block;
    }

    .results-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 6px;
      color: var(--neutral-500);
      font-size: 14px;
    }

    .property-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 18px;
    }


    .property-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: var(--radius-md);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: var(--shadow-soft);
      text-decoration: none;
      color: inherit;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .property-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.16);
    }

    .property-card .thumbnail {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      height: 150px;
      background: #e2e8f0;
      display: flex;
      align-items: flex-end;
      justify-content: flex-start;
      padding: 18px;
      color: var(--heading);
      font-weight: 600;
    }

    .property-card .thumbnail img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      transition: transform 0.3s ease;
    }

    .property-card .thumbnail.has-image {
      color: #fff;
    }

    .property-card .thumbnail.has-image .thumbnail-label {
      text-shadow: 0 2px 8px rgba(15, 23, 42, 0.35);
    }

    .property-card .thumbnail.no-image {
      background: #e2e8f0;
      color: var(--heading);
    }

    .property-card .thumbnail.no-image::after {
      content: none;
    }

    .property-card .thumbnail-label {
      position: relative;
      z-index: 2;
    }

    .property-card .badge-set {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .badge {
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .badge.new {
      background: rgba(59, 130, 246, 0.16);
      color: #1d4ed8;
    }

    .badge.hot {
      background: rgba(244, 114, 182, 0.18);
      color: #be185d;
    }

    .badge.plan {
      background: rgba(234, 179, 8, 0.18);
      color: #b45309;
    }

    .badge.buy {
      background: rgba(16, 185, 129, 0.2);
      color: #047857;
    }

    .badge.rent {
      background: rgba(99, 102, 241, 0.18);
      color: #4338ca;
    }

    .badge.offplan {
      background: rgba(249, 115, 22, 0.18);
      color: #c2410c;
    }

    .property-card h4 {
      margin: 0;
      font-size: 15px;
      color: var(--heading);
    }

    .property-card .details {
      display: flex;
      flex-direction: column;
      gap: 6px;
      color: var(--neutral-500);
      font-size: 13px;
    }

    .property-card .details .property-type {
      font-weight: 500;
      color: var(--primary-dark);
    }

    .property-card .details .secondary-name {
      font-weight: 500;
    }

    .property-card .details .starting-price {
      font-size: 16px;
      font-weight: 600;
      color: var(--primary);
    }

    .property-card .actions {
      display: flex;
      gap: 10px;
      font-size: 12px;
      color: var(--neutral-500);
    }

    .property-card .actions span {
      background: rgba(15, 23, 42, 0.06);
      border-radius: 12px;
      padding: 8px 12px;
      font-weight: 600;
      color: var(--primary-dark);
    }

    .property-card:hover .thumbnail img {
      transform: scale(1.05);
    }

    .empty-state {
      grid-column: 1 / -1;
      background: rgba(255, 255, 255, 0.8);
      border-radius: var(--radius-md);
      padding: 28px;
      text-align: center;
      color: var(--neutral-500);
      box-shadow: var(--shadow-soft);
    }

    .loading-indicator {
      text-align: center;
      padding: 24px;
      color: var(--neutral-500);
      font-weight: 500;
    }

    @media (max-width: 960px) {
      .page {
        flex-direction: column;
      }

      .map-legend {
        left: 50%;
        transform: translateX(-50%);
      }
    }
  </style>
</head>

<body>
  <main class="page">
    <aside class="sidebar">
      <div class="brand">
        <h1>HouzzHunt </h1>
      </div>

      <section class="location-search">
        <label for="filterSearchLocation">Search Location</label>
        <div class="input-group">
          <input id="filterSearchLocation" type="text" placeholder="Search by location, community" />
        </div>
        <div class="input-group">
          <label for="filterCategory">Listing Category</label>
          <select id="filterCategory" aria-label="Listing category">
            <option value="all">All</option>
            <option value="buy">Buy</option>
            <option value="rent">Rent</option>
            <option value="offplan">Off-Plan</option>
          </select>
          <button type="button" id="useCurrentLocation">Use current location</button>
        </div>
      </section>

      <section class="filters">
        <h2>Project Filters</h2>
        <div class="filter-fields">
          <div class="input-group">
            <label for="filterProjectName">Project Name</label>
            <input id="filterProjectName" type="text" placeholder="e.g. Creek Waters" />
          </div>
          <div class="input-group">
            <label for="filterLocation">Location</label>
            <input id="filterLocation" type="text" list="filterLocationOptions" placeholder="e.g. Downtown Dubai" />
            <datalist id="filterLocationOptions"></datalist>
          </div>
          <div class="input-group">
            <label for="filterPropertyType">Property Type</label>
            <select id="filterPropertyType">
              <option value="">Any</option>
            </select>
          </div>
          <div class="input-group">
            <label for="filterBedrooms">Bedrooms</label>
            <select id="filterBedrooms">
              <option value="">Any</option>
            </select>
          </div>
          <div class="input-group">
            <label for="filterCompletionYear">Completion Year</label>
            <select id="filterCompletionYear">
              <option value="">Any</option>
            </select>
          </div>
          <div class="input-group">
            <label for="filterMinPrice">Min Price</label>
            <input id="filterMinPrice" type="number" min="0" placeholder="e.g. 500000" />
          </div>
          <div class="input-group">
            <label for="filterMaxPrice">Max Price</label>
            <input id="filterMaxPrice" type="number" min="0" placeholder="e.g. 2500000" />
          </div>
        </div>
        <div class="filter-actions">
          <button class="secondary" id="clearFilters" type="button">Clear All</button>
          <button class="primary" id="applyFilters" type="button">Apply Filters</button>
        </div>
      </section>

      <section class="filters">
        <h2>Popular Communities</h2>
        <div class="filter-group">
          <label><input type="checkbox" /> Dubai Hills Estate</label>
          <label><input type="checkbox" /> Palm Jumeirah</label>
          <label><input type="checkbox" /> Downtown Dubai</label>
          <label><input type="checkbox" /> Dubai Marina</label>
        </div>
      </section>
    </aside>

    <section class="map-section">
      <div class="tabs" role="tablist">
        <button class="active" type="button" data-category="all" role="tab" aria-selected="true">
          All
        </button>
        <button type="button" data-category="buy" role="tab" aria-selected="false">Buy</button>
        <button type="button" data-category="rent" role="tab" aria-selected="false">Rent</button>
        <button type="button" data-category="offplan" role="tab" aria-selected="false">
          Off-Plan
        </button>
      </div>

      <div class="map-canvas" aria-label="Interactive property map">
        <div id="propertyMap" role="application" aria-label="Property locations"></div>
        <div class="map-legend" id="mapLegend" aria-hidden="true"></div>
      </div>

      <div class="results-meta">
        <span id="resultsCount">Loading properties...</span>
        <span id="resultsInfo">&nbsp;</span>
      </div>

      <div class="property-grid" id="propertyGrid">
        <div class="loading-indicator" id="loadingState">Fetching the latest listings...</div>
      </div>
    </section>
  </main>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin="anonymous"></script>
  <script>
    (function () {
      const CATEGORY_CONFIG = {
        all: { label: 'All', color: '#0ea5e9' },
        buy: { label: 'Buy', color: '#10b981' },
        rent: { label: 'Rent', color: '#6366f1' },
        offplan: { label: 'Off-Plan', color: '#f97316' },
      };

      const CATEGORY_RENDER_ORDER = ['buy', 'rent', 'offplan'];
      const DUPLICATE_MARKER_OFFSET_STEP = 0.0002;

      const state = {
        properties: [],
        markers: [],
        activeCategory: 'all',
        filters: {
          projectName: '',
          location: '',
          propertyType: '',
          bedrooms: '',
          searchLocation: '',
          completionYear: '',
          minPrice: '',
          maxPrice: '',
        },
      };

      const mapCanvas = document.getElementById('propertyMap');
      const propertyGrid = document.getElementById('propertyGrid');
      const resultsCount = document.getElementById('resultsCount');
      const resultsInfo = document.getElementById('resultsInfo');
      const legend = document.getElementById('mapLegend');
      const loadingState = document.getElementById('loadingState');
      const tabs = Array.from(document.querySelectorAll('.tabs button[data-category]'));
      const categorySelect = document.getElementById('filterCategory');
      const filterElements = {
        projectName: document.getElementById('filterProjectName'),
        location: document.getElementById('filterLocation'),
        propertyType: document.getElementById('filterPropertyType'),
        bedrooms: document.getElementById('filterBedrooms'),
        searchLocation: document.getElementById('filterSearchLocation'),
        completionYear: document.getElementById('filterCompletionYear'),
        minPrice: document.getElementById('filterMinPrice'),
        maxPrice: document.getElementById('filterMaxPrice'),
      };
      const locationDatalist = document.getElementById('filterLocationOptions');
      const applyFiltersButton = document.getElementById('applyFilters');
      const clearFiltersButton = document.getElementById('clearFilters');

      let map;
      let markersLayer;

      const escapeHtml = (value) => {
        const div = document.createElement('div');
        div.textContent = value == null ? '' : String(value);
        return div.innerHTML;
      };

      const initMap = () => {
        map = L.map(mapCanvas, {
          scrollWheelZoom: false,
        }).setView([25.2048, 55.2708], 11);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          maxZoom: 18,
        }).addTo(map);

        markersLayer = L.layerGroup().addTo(map);
      };

      const createMarkerIcon = (color, label) => {
        const safeLabel = escapeHtml(label).slice(0, 3).toUpperCase();
        const html = `
          <div style="
            background:${color};
            color:#fff;
            width:44px;
            height:44px;
            border-radius:50% 50% 50% 0;
            transform:rotate(-45deg);
            display:grid;
            place-items:center;
            box-shadow:0 18px 30px rgba(15, 23, 42, 0.28);
            font-weight:700;
            font-size:13px;
          ">
            <span style="transform:rotate(45deg);">${safeLabel}</span>
          </div>`;

        return L.divIcon({
          className: 'property-marker',
          html,
          iconSize: [44, 44],
          iconAnchor: [22, 42],
          popupAnchor: [0, -32],
        });
      };

      const PLACEHOLDER_IMAGE = 'assets/images/properties-listing/breez-by-danube-list.webp';

      const normaliseImageSource = (value) => {
        if (typeof value !== 'string') {
          return null;
        }

        const trimmed = value.trim();
        if (!trimmed) {
          return null;
        }

        const lowerTrimmed = trimmed.toLowerCase();
        if (
          lowerTrimmed.startsWith('http://') ||
          lowerTrimmed.startsWith('https://') ||
          lowerTrimmed.startsWith('//') ||
          lowerTrimmed.startsWith('data:') ||
          lowerTrimmed.startsWith('blob:')
        ) {
          return trimmed;
        }

        if (trimmed.startsWith('/')) {
          return trimmed.replace(/\/+/, '/');
        }

        return `/${trimmed}`.replace(/\/+/, '/');
      };

      const normaliseDisplayText = (value) => {
        if (typeof value !== 'string') {
          return '';
        }

        const trimmed = value.trim();
        return trimmed;
      };

      const resolveDisplayData = (property) => {
        if (!property || typeof property !== 'object') {
          return {
            primary: 'Project name unavailable',
            secondary: '',
            projectName: '',
            location: '',
          };
        }

        const normalise = normaliseDisplayText;
        const projectName = normalise(property.project_name ?? property.projectName);
        const candidateValues = [
          projectName,
          normalise(property.display_name ?? property.displayName),
          normalise(property.project_title ?? property.projectTitle),
          normalise(property.property_title ?? property.propertyTitle),
          normalise(property.title),
          normalise(property.name),
        ].filter(Boolean);

        const locationValue =
          normalise(property.location_highlight ?? property.locationHighlight) ||
          normalise(property.location);

        const primary =
          candidateValues.find((value) => value) || locationValue || 'Project name unavailable';

        const secondary =
          locationValue || candidateValues.find((value) => value && value !== primary) || '';

        return {
          primary,
          secondary,
          projectName,
          location: locationValue,
        };
      };

      const resolvePropertyImage = (property) => {
        if (!property || typeof property !== 'object') {
          return null;
        }

        const candidateKeys = [
          'project_image_url',
          'projectImageUrl',
          'project_image',
          'projectImage',
          'project_hero_banner_url',
          'projectHeroBannerUrl',
          'project_hero_banner',
          'projectHeroBanner',
          'hero_image_url',
          'heroImageUrl',
          'hero_banner_url',
          'heroBannerUrl',
          'hero_banner',
          'heroBanner',
          'image_url',
          'imageUrl',
          'primary_image',
          'primaryImage',
        ];

        for (const key of candidateKeys) {
          const value = normaliseImageSource(property[key]);
          if (value) {
            return value;
          }
        }

        const galleryCandidates = Array.isArray(property.gallery_images)
          ? property.gallery_images
          : Array.isArray(property.galleryImages)
            ? property.galleryImages
            : [];

        for (const item of galleryCandidates) {
          if (typeof item === 'string') {
            const value = normaliseImageSource(item);
            if (value) {
              return value;
            }
          } else if (item && typeof item === 'object') {
            for (const value of Object.values(item)) {
              const normalised = normaliseImageSource(value);
              if (normalised) {
                return normalised;
              }
            }
          }
        }

        return null;
      };

      const normaliseFilterText = (value) => {
        if (typeof value !== 'string') {
          return '';
        }

        return value.trim().toLowerCase();
      };

      const getCompletionYear = (property) => {
        if (!property || typeof property !== 'object') {
          return '';
        }

        const value =
          property.completion_year ??
          property.completionYear ??
          property.handover_year ??
          property.handoverYear ??
          '';

        if (typeof value === 'number') {
          return Number.isFinite(value) ? String(value) : '';
        }

        if (typeof value === 'string') {
          return value.trim();
        }

        return '';
      };

      const parsePriceValue = (value) => {
        if (typeof value === 'number') {
          return Number.isFinite(value) ? value : null;
        }

        if (typeof value !== 'string') {
          return null;
        }

        const cleaned = value.replace(/[^0-9.]/g, '');
        if (!cleaned) {
          return null;
        }

        const number = Number(cleaned);
        return Number.isFinite(number) ? number : null;
      };

      const toFiniteNumber = (value) => {
        if (value === '' || value === null || value === undefined) {
          return null;
        }

        const number = Number(value);
        return Number.isFinite(number) ? number : null;
      };

      const populateSelectOptions = (select, values, placeholder = 'Any') => {
        if (!select) {
          return;
        }

        const previousValue = select.value;
        const fragment = document.createDocumentFragment();
        const defaultOption = document.createElement('option');
        defaultOption.value = '';
        defaultOption.textContent = placeholder;
        fragment.appendChild(defaultOption);

        values.forEach((value) => {
          const option = document.createElement('option');
          option.value = value;
          option.textContent = value;
          fragment.appendChild(option);
        });

        select.innerHTML = '';
        select.appendChild(fragment);

        if (values.includes(previousValue)) {
          select.value = previousValue;
        } else {
          select.value = '';
        }
      };

      const populateDatalistOptions = (datalist, values) => {
        if (!datalist) {
          return;
        }

        datalist.innerHTML = '';

        values.forEach((value) => {
          const option = document.createElement('option');
          option.value = value;
          datalist.appendChild(option);
        });
      };

      const populateFilterOptions = () => {
        if (!Array.isArray(state.properties)) {
          return;
        }

        const propertyTypes = new Set();
        const bedrooms = new Set();
        const locations = new Set();
        const completionYears = new Set();

        state.properties.forEach((property) => {
          if (!property || typeof property !== 'object') {
            return;
          }

          const propertyType = typeof property.property_type === 'string' ? property.property_type.trim() : '';
          if (propertyType) {
            propertyTypes.add(propertyType);
          }

          const bedroomValue = typeof property.bedrooms === 'string' ? property.bedrooms.trim() : '';
          if (bedroomValue) {
            bedrooms.add(bedroomValue);
          }

          const locationValue =
            (typeof property.location_highlight === 'string' && property.location_highlight.trim()) ||
            (typeof property.location === 'string' && property.location.trim()) ||
            '';
          if (locationValue) {
            locations.add(locationValue);
          }

          const completionYear = getCompletionYear(property);
          if (completionYear) {
            completionYears.add(completionYear);
          }
        });

        const sortAlpha = (a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' });
        const extractLeadingNumber = (value) => {
          const match = value.match(/\d+(?:\.\d+)?/);
          return match ? Number(match[0]) : Number.POSITIVE_INFINITY;
        };

        const propertyTypeOptions = Array.from(propertyTypes).sort(sortAlpha);
        const bedroomOptions = Array.from(bedrooms).sort((a, b) => {
          const aNum = extractLeadingNumber(a);
          const bNum = extractLeadingNumber(b);

          if (Number.isFinite(aNum) && Number.isFinite(bNum) && aNum !== bNum) {
            return aNum - bNum;
          }

          return a.localeCompare(b, undefined, { sensitivity: 'base' });
        });
        const locationOptions = Array.from(locations).sort(sortAlpha);
        const completionYearOptions = Array.from(completionYears).sort(sortAlpha);

        populateSelectOptions(filterElements.propertyType, propertyTypeOptions, 'Any type');
        populateSelectOptions(filterElements.bedrooms, bedroomOptions, 'Any bedrooms');
        populateSelectOptions(filterElements.completionYear, completionYearOptions, 'Any year');
        populateDatalistOptions(locationDatalist, locationOptions);
      };

      const applyActiveFilters = (properties) => {
        if (!Array.isArray(properties)) {
          return [];
        }

        const { filters } = state;
        const projectNameFilter = normaliseFilterText(filters.projectName);
        const locationFilter = normaliseFilterText(filters.location);
        const propertyTypeFilter = normaliseFilterText(filters.propertyType);
        const bedroomsFilter = normaliseFilterText(filters.bedrooms);
        const searchLocationFilter = normaliseFilterText(filters.searchLocation);
        const completionYearFilter = normaliseFilterText(filters.completionYear);
        const minPriceFilter = toFiniteNumber(filters.minPrice);
        const maxPriceFilter = toFiniteNumber(filters.maxPrice);

        return properties.filter((property) => {
          if (!property || typeof property !== 'object') {
            return false;
          }

          if (projectNameFilter) {
            const candidates = [
              property.project_name,
              property.projectName,
              property.display_name,
              property.displayName,
              property.project_title,
              property.projectTitle,
              property.property_title,
              property.propertyTitle,
              property.title,
            ];

            const matchesProject = candidates.some((candidate) =>
              normaliseFilterText(candidate).includes(projectNameFilter)
            );

            if (!matchesProject) {
              return false;
            }
          }

          if (locationFilter) {
            const locationCandidates = [property.location_highlight, property.location, property.locationHighlight];
            const matchesLocation = locationCandidates.some((candidate) =>
              normaliseFilterText(candidate).includes(locationFilter)
            );

            if (!matchesLocation) {
              return false;
            }
          }

          if (searchLocationFilter) {
            const searchCandidates = [
              property.location_highlight,
              property.location,
              property.locationHighlight,
              property.project_name,
              property.projectName,
              property.display_name,
              property.displayName,
              property.project_title,
              property.projectTitle,
              property.property_title,
              property.propertyTitle,
              property.title,
            ];

            const matchesSearch = searchCandidates.some((candidate) =>
              normaliseFilterText(candidate).includes(searchLocationFilter)
            );

            if (!matchesSearch) {
              return false;
            }
          }

          if (propertyTypeFilter) {
            const propertyTypeValue = normaliseFilterText(property.property_type || property.propertyType);
            if (!propertyTypeValue || !propertyTypeValue.includes(propertyTypeFilter)) {
              return false;
            }
          }

          if (bedroomsFilter) {
            const bedroomsValue = normaliseFilterText(property.bedrooms || property.bedroomCount);
            if (!bedroomsValue || !bedroomsValue.includes(bedroomsFilter)) {
              return false;
            }
          }

          if (completionYearFilter) {
            const completionValue = normaliseFilterText(getCompletionYear(property));
            if (!completionValue || !completionValue.includes(completionYearFilter)) {
              return false;
            }
          }

          if (minPriceFilter !== null || maxPriceFilter !== null) {
            const numericPrice = parsePriceValue(property.price ?? property.starting_price ?? property.startingPrice);

            if (minPriceFilter !== null && (numericPrice === null || numericPrice < minPriceFilter)) {
              return false;
            }

            if (maxPriceFilter !== null && (numericPrice === null || numericPrice > maxPriceFilter)) {
              return false;
            }
          }

          return true;
        });
      };

      const renderLegend = () => {
        legend.innerHTML = '';
        legend.setAttribute('aria-hidden', 'false');

        Object.entries(CATEGORY_CONFIG).forEach(([key, config]) => {
          if (key === 'all') {
            return;
          }

          const item = document.createElement('span');
          item.className = 'legend-item';
          item.style.color = config.color;

          const dot = document.createElement('span');
          dot.className = 'legend-dot';
          item.appendChild(dot);

          const text = document.createElement('span');
          text.textContent = config.label;
          item.appendChild(text);

          legend.appendChild(item);
        });
      };

      const clearMarkers = () => {
        markersLayer.clearLayers();
        state.markers = [];
      };

      const fitMapToMarkers = () => {
        if (state.markers.length === 0) {
          map.setView([25.2048, 55.2708], 11);
          return;
        }

        const group = L.featureGroup(state.markers);
        map.fitBounds(group.getBounds(), { padding: [24, 24], maxZoom: 16 });
      };

      const hasValidCoordinates = (property) =>
        Number.isFinite(property.latitude) && Number.isFinite(property.longitude);

      const getPropertiesForCategory = (category) => {
        if (category === 'all') {
          const grouped = CATEGORY_RENDER_ORDER.flatMap((key) =>
            state.properties.filter((property) => property.category_key === key)
          );

          const remaining = state.properties.filter(
            (property) => !CATEGORY_RENDER_ORDER.includes(property.category_key)
          );

          return [...grouped, ...remaining];
        }

        return state.properties.filter((property) => property.category_key === category);
      };

      const renderProperties = () => {
        const category = state.activeCategory;
        const categoryProperties = getPropertiesForCategory(category);
        const filtered = applyActiveFilters(categoryProperties);
        const pinnedProperties = filtered.filter(hasValidCoordinates);

        resultsCount.textContent =
          filtered.length === 1 ? '1 property shown' : `${filtered.length} properties shown`;

        const activeCategoryConfig = CATEGORY_CONFIG[category];
        const categoryLabel = (activeCategoryConfig && activeCategoryConfig.label) || category;
        const filterCount = Object.values(state.filters).filter((value) => value).length;

        resultsInfo.textContent =
          category === 'all'
            ? `Displaying Buy, Rent, and Off-Plan listings · ${pinnedProperties.length} pinned on the map` +
              (filterCount > 0 ? ` · ${filterCount} active filter${filterCount > 1 ? 's' : ''}` : '')
            : `Category: ${categoryLabel} · ${pinnedProperties.length} pinned on the map` +
              (filterCount > 0 ? ` · ${filterCount} active filter${filterCount > 1 ? 's' : ''}` : '');

        propertyGrid.innerHTML = '';

        if (filtered.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'empty-state';
          empty.textContent =
            filterCount > 0
              ? 'No properties match the current filters. Try adjusting your selections.'
              : 'No properties available for the selected category yet.';
          propertyGrid.appendChild(empty);
        } else {
          filtered.forEach((property) => {
            const card = document.createElement('a');
            card.className = 'property-card';
            card.href = property.details_url || '#';
            const displayData = resolveDisplayData(property);
            const displayTitle = displayData.primary;
            card.setAttribute('aria-label', `View details for ${displayTitle}`);

            const thumbnail = document.createElement('div');
            thumbnail.className = 'thumbnail';

            const thumbnailUrl = resolvePropertyImage(property);
            const previewImage = document.createElement('img');
            const hasResolvedImage = Boolean(thumbnailUrl);

            if (hasResolvedImage) {
              thumbnail.classList.add('has-image');
              previewImage.src = thumbnailUrl;
            } else {
              thumbnail.classList.add('no-image');
              previewImage.src = PLACEHOLDER_IMAGE;
            }
            previewImage.alt = `${displayTitle} preview`;
            previewImage.loading = 'lazy';
            previewImage.decoding = 'async';

            previewImage.addEventListener('error', () => {
              if (previewImage.dataset.fallbackApplied === 'true') {
                return;
              }

              previewImage.dataset.fallbackApplied = 'true';
              previewImage.src = PLACEHOLDER_IMAGE;
              thumbnail.classList.remove('has-image');
              thumbnail.classList.add('no-image');
            });

            thumbnail.appendChild(previewImage);

            card.appendChild(thumbnail);

            const badges = document.createElement('div');
            badges.className = 'badge-set';

            const categoryBadge = document.createElement('span');
            categoryBadge.className = `badge ${property.category_key}`;
            const categoryConfig = CATEGORY_CONFIG[property.category_key];
            categoryBadge.textContent =
              (categoryConfig && categoryConfig.label) ||
              property.category_label ||
              property.category_key;
            badges.appendChild(categoryBadge);

            if (property.property_type) {
              const typeBadge = document.createElement('span');
              typeBadge.className = 'badge new';
              typeBadge.textContent = property.property_type;
              badges.appendChild(typeBadge);
            }

            card.appendChild(badges);

            const title = document.createElement('h4');
            title.textContent = displayTitle;
            card.appendChild(title);

            const details = document.createElement('div');
            details.className = 'details';

            const propertyTypeValue = property.property_type || property.propertyType || '';
            const propertyType = typeof propertyTypeValue === 'string' ? propertyTypeValue.trim() : '';
            if (propertyType) {
              const typeInfo = document.createElement('span');
              typeInfo.className = 'property-type';
              typeInfo.textContent = propertyType;
              details.appendChild(typeInfo);
            }

            const secondaryName =
              displayData.location || (displayData.secondary !== displayTitle ? displayData.secondary : '');
            if (secondaryName && secondaryName !== displayTitle) {
              const secondaryInfo = document.createElement('span');
              secondaryInfo.className = 'secondary-name';
              secondaryInfo.textContent = secondaryName;
              details.appendChild(secondaryInfo);
            }

            const rawStartingPrice =
              property.starting_price ||
              property.startingPrice ||
              property.price ||
              property.price_display ||
              property.priceDisplay ||
              '';

            let startingPriceText = '';
            if (typeof rawStartingPrice === 'number' && Number.isFinite(rawStartingPrice)) {
              startingPriceText = `Starting Price: AED ${rawStartingPrice.toLocaleString('en-US')}`;
            } else if (typeof rawStartingPrice === 'string') {
              const trimmedPrice = rawStartingPrice.trim();
              if (trimmedPrice) {
                startingPriceText = /starting/i.test(trimmedPrice)
                  ? trimmedPrice
                  : `Starting Price: ${trimmedPrice}`;
              }
            }

            if (startingPriceText) {
              const startingPrice = document.createElement('span');
              startingPrice.className = 'starting-price';
              startingPrice.textContent = startingPriceText;
              details.appendChild(startingPrice);
            }

            if (details.childNodes.length > 0) {
              card.appendChild(details);
            }

            const actions = document.createElement('div');
            actions.className = 'actions';
            const actionLabel = document.createElement('span');
            actionLabel.textContent = 'View Details';
            actions.appendChild(actionLabel);
            card.appendChild(actions);

            propertyGrid.appendChild(card);
          });
        }

        clearMarkers();

        const coordinateUsage = new Map();

        pinnedProperties.forEach((property) => {
          const baseKey = `${property.latitude.toFixed(6)}:${property.longitude.toFixed(6)}`;
          const occurrenceIndex = coordinateUsage.get(baseKey) || 0;
          coordinateUsage.set(baseKey, occurrenceIndex + 1);

          let markerLatitude = property.latitude;
          let markerLongitude = property.longitude;

          if (occurrenceIndex > 0) {
            const angle = ((occurrenceIndex - 1) % 6) * (Math.PI / 3);
            const ringIndex = Math.floor((occurrenceIndex - 1) / 6) + 1;
            const radius = ringIndex * DUPLICATE_MARKER_OFFSET_STEP;
            markerLatitude += Math.sin(angle) * radius;
            markerLongitude += Math.cos(angle) * radius;
          }

          const categoryConfig = CATEGORY_CONFIG[property.category_key];
          const categoryColor = (categoryConfig && categoryConfig.color) || '#0f172a';
          const marker = L.marker([markerLatitude, markerLongitude], {
            icon: createMarkerIcon(categoryColor, property.category_label || property.category_key),
          });

          const displayData = resolveDisplayData(property);
          const popupTitle = displayData.primary;
          const popupLocation = displayData.location || displayData.secondary;

          const popupContent = `
            <div style="min-width:180px;">
              <strong>${escapeHtml(popupTitle)}</strong><br />
              <span>${escapeHtml(popupLocation || property.location || '')}</span><br />
              <a href="${escapeHtml(property.details_url || '#')}" style="color:${categoryColor};font-weight:600;display:inline-block;margin-top:8px;">View details</a>
            </div>
          `;

          marker.bindPopup(popupContent);
          marker.on('click', () => {
            marker.openPopup();
          });

          marker.addTo(markersLayer);
          state.markers.push(marker);
        });

        fitMapToMarkers();
      };

      const setActiveCategory = (category) => {
        const resolvedCategory = Object.prototype.hasOwnProperty.call(CATEGORY_CONFIG, category)
          ? category
          : 'all';

        state.activeCategory = resolvedCategory;

        tabs.forEach((tab) => {
          const isActive = tab.dataset.category === resolvedCategory;
          tab.classList.toggle('active', isActive);
          tab.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });

        if (categorySelect) {
          categorySelect.value = resolvedCategory;
        }

        renderProperties();
      };

      const fetchProperties = async () => {
        try {
          const response = await fetch('property-map-data.php', {
            headers: { 'X-Requested-With': 'XMLHttpRequest' },
          });

          if (!response.ok) {
            throw new Error(`Failed to fetch property data (HTTP ${response.status})`);
          }

          const payload = await response.json();

          if (!payload || !Array.isArray(payload.properties)) {
            throw new Error('Unexpected response format');
          }

          const normaliseCategoryKey = (value) => {
            if (typeof value !== 'string') {
              return null;
            }

            const trimmed = value.trim().toLowerCase();
            if (!trimmed) {
              return null;
            }

            if (['off-plan', 'off_plan', 'off plan'].includes(trimmed)) {
              return 'offplan';
            }

            return trimmed;
          };

          const parseCoordinate = (value) => {
            const number = Number(value);
            return Number.isFinite(number) ? number : null;
          };

          state.properties = payload.properties
            .map((property) => {
              const normalisedKey = normaliseCategoryKey(
                property.category_key ?? property.category ?? ''
              );
              if (!normalisedKey) {
                return null;
              }

              const categoryConfig = CATEGORY_CONFIG[normalisedKey];
              const normalisedLabel =
                property.category_label ||
                (categoryConfig && categoryConfig.label) ||
                normalisedKey.replace(/\b\w/g, (match) => match.toUpperCase());

              return {
                ...property,
                category_key: normalisedKey,
                category_label: normalisedLabel,
                latitude: parseCoordinate(property.latitude),
                longitude: parseCoordinate(property.longitude),
              };
            })
            .filter(Boolean);

          populateFilterOptions();
          renderLegend();
          setActiveCategory('all');
        } catch (error) {
          console.error(error);
          resultsCount.textContent = 'Unable to load properties right now.';
          resultsInfo.textContent = 'Please try again later.';

          propertyGrid.innerHTML = '';
          const errorState = document.createElement('div');
          errorState.className = 'empty-state';
          errorState.textContent = 'There was a problem loading the map data. Please refresh to try again.';
          propertyGrid.appendChild(errorState);
        } finally {
          if (loadingState) {
            loadingState.remove();
          }
        }
      };

      const registerFilterInput = (key, element, eventName = 'input') => {
        if (!element) {
          return;
        }

        element.addEventListener(eventName, () => {
          state.filters[key] = element.value;
          renderProperties();
        });
      };

      const clearAllFilters = () => {
        Object.entries(filterElements).forEach(([key, element]) => {
          if (!element) {
            return;
          }

          if (element.tagName === 'SELECT') {
            element.value = '';
          } else {
            element.value = '';
          }

          state.filters[key] = '';
        });

        setActiveCategory('all');
      };

      registerFilterInput('projectName', filterElements.projectName);
      registerFilterInput('location', filterElements.location);
      registerFilterInput('propertyType', filterElements.propertyType, 'change');
      registerFilterInput('bedrooms', filterElements.bedrooms, 'change');
      registerFilterInput('searchLocation', filterElements.searchLocation);
      registerFilterInput('completionYear', filterElements.completionYear, 'change');
      registerFilterInput('minPrice', filterElements.minPrice);
      registerFilterInput('maxPrice', filterElements.maxPrice);

      if (applyFiltersButton) {
        applyFiltersButton.addEventListener('click', () => {
          renderProperties();
        });
      }

      if (clearFiltersButton) {
        clearFiltersButton.addEventListener('click', () => {
          clearAllFilters();
        });
      }

      if (categorySelect) {
        categorySelect.addEventListener('change', () => {
          const selectedValue = categorySelect.value || 'all';
          if (selectedValue !== state.activeCategory) {
            setActiveCategory(selectedValue);
          } else {
            renderProperties();
          }
        });
      }

      tabs.forEach((tab) => {
        tab.addEventListener('click', () => {
          const category = tab.dataset.category;
          if (category && category !== state.activeCategory) {
            setActiveCategory(category);
          }
        });
      });

      initMap();
      renderLegend();
      fetchProperties();
    })();
  </script>
</body>

</html>